{
  "manifest": {
    "name": "@wasm-audio-decoders/ogg-vorbis",
    "version": "0.1.16",
    "description": "Web Assembly streaming Ogg Vorbis decoder",
    "type": "module",
    "main": "./index.js",
    "exports": {
      "types": "./types.d.ts",
      "default": "./index.js"
    },
    "sideEffects": false,
    "types": "types.d.ts",
    "files": [
      "index.js",
      "types.d.ts",
      "src/EmscriptenWasm.js",
      "src/OggVorbisDecoder.js",
      "src/OggVorbisDecoderWebWorker.js",
      "dist/ogg-vorbis-decoder.min.js",
      "dist/ogg-vorbis-decoder.min.js.map"
    ],
    "keywords": [
      "Vorbis",
      "Ogg",
      "audio",
      "decoder",
      "multichannel",
      "surround",
      "stream",
      "streams",
      "libvorbis",
      "Web Assembly",
      "Wasm",
      "Web Worker"
    ],
    "author": {
      "name": "Ethan Halsall",
      "email": "ethanhalsall@pm.me"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/eshaz/wasm-audio-decoders/issues"
    },
    "homepage": "https://github.com/eshaz/wasm-audio-decoders/tree/master/src/ogg-vorbis",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/eshaz/wasm-audio-decoders.git",
      "directory": "src/ogg-vorbis"
    },
    "funding": {
      "type": "individual",
      "url": "https://github.com/sponsors/eshaz"
    },
    "dependencies": {
      "@wasm-audio-decoders/common": "9.0.5",
      "codec-parser": "2.5.0"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-@wasm-audio-decoders-ogg-vorbis-0.1.16-56c17fb7366599cc81ab11639e5d39dd15b3a81d-integrity/node_modules/@wasm-audio-decoders/ogg-vorbis/package.json",
    "readmeFilename": "README.md",
    "readme": "# `@wasm-audio-decoders/ogg-vorbis`\n\n`@wasm-audio-decoders/ogg-vorbis` is a Web Assembly Ogg Vorbis audio decoder.\n  * 97.9 KiB minified bundle size\n  * Browser and NodeJS support\n  * Built in Web Worker support\n  * Multichannel decoding (up to 255 channels)\n  * Supports full Vorbis sample rate.\n  * Based on [`libvorbis`](https://github.com/xiph/vorbis) and [`codec-parser`](https://github.com/eshaz/codec-parser)\n\nSee the [homepage](https://github.com/eshaz/wasm-audio-decoders) of this repository for more Web Assembly audio decoders like this one.\n\n### [Checkout the demo here](https://eshaz.github.io/wasm-audio-decoders/)\n\n## Installing\n* Install from [NPM](https://www.npmjs.com/package/@wasm-audio-decoders/ogg-vorbis).\n\n  Run `npm i @wasm-audio-decoders/ogg-vorbis`\n\n  ```javascript\n  import { OggVorbisDecoder } from '@wasm-audio-decoders/ogg-vorbis';\n\n  const decoder = new OggVorbisDecoder();\n  ```\n \n* Or download the [build](https://github.com/eshaz/wasm-audio-decoders/tree/master/src/vorbis/dist) and include it as a script.\n  ```html\n  <script src=\"ogg-vorbis-decoder.min.js\"></script>\n  <script>\n    const decoder = new window[\"ogg-vorbis-decoder\"].OggVorbisDecoder();\n  </script>\n  ```\n\n## Usage\n\n1. Create a new instance and wait for the WASM to finish compiling. Decoding can be done on the main thread synchronously, or in a web worker asynchronously.\n\n   **Main thread synchronous decoding**\n   ```javascript\n   import { OggVorbisDecoder } from '@wasm-audio-decoders/ogg-vorbis';\n\n   const decoder = new OggVorbisDecoder();\n\n   // wait for the WASM to be compiled\n   await decoder.ready;\n   ```\n\n   **Web Worker asynchronous decoding**\n   ```javascript\n   import { OggVorbisDecoderWebWorker } from '@wasm-audio-decoders/ogg-vorbis';\n\n   const decoder = new OggVorbisDecoderWebWorker();\n\n   // wait for the WASM to be compiled\n   await decoder.ready;\n   ```\n\n1. Begin decoding Ogg Vorbis data.\n\n   ```javascript  \n   // Decode an individual Opus frame\n   const {channelData, samplesDecoded, sampleRate, bitDepth} = decoder.decode(vorbisData);\n   ```\n\n1. When done decoding, reset the decoder to decode a new stream, or free up the memory being used by the WASM module if you have no more audio to decode. \n\n   ```javascript\n   // `reset()` clears the decoder state and allows you do decode a new stream of Ogg Vorbis data.\n   await decoder.reset();\n\n   // `free()` de-allocates the memory used by the decoder. You will need to create a new instance after calling `free()` to start decoding again.\n   decoder.free();\n   ```\n\n## API\n\nDecoded audio is always returned in the below structure.\n\n```javascript\n{\n    channelData: [\n      leftAudio, // Float32Array of PCM samples for the left channel\n      rightAudio, // Float32Array of PCM samples for the right channel\n      ... // additional channels\n    ],\n    samplesDecoded: 1234, // number of PCM samples that were decoded per channel\n    sampleRate: 48000, // sample rate of the decoded PCM\n    bitDepth: 16, // bit depth of the original Ogg Vorbis file\n    errors: [ // array containing descriptions for any decode errors\n      {\n        message: \"OV_ENOTVORBIS the packet is not a Vorbis header packet.\",\n        frameLength: 400, // length of the frame or data in bytes that encountered an error\n        frameNumber: 5, // position of error relative to total frames decoded \n        inputBytes: 11606, // position of error relative to total input bytes\n        outputSamples: 20480, // position of error relative to total output samples\n      }\n    ]\n}\n```\n\nEach Float32Array within `channelData` can be used directly in the WebAudio API for playback.\n\nDecoding will proceed through any errors. Any errors encountered may result in gaps in the decoded audio.\n\n### Multichannel Output\n\nEach channel is assigned to a speaker location in a conventional surround arrangement. Specific locations depend on the number of channels, and are given below in order of the corresponding channel indices. This set of surround options and speaker location orderings is the same as those used by the Vorbis codec.\n\n* 1 channel: monophonic (mono).\n* 2 channels: stereo (left, right).\n* 3 channels: linear surround (left, center, right).\n* 4 channels: quadraphonic (front left, front right, rear left, rear right).\n* 5 channels: 5.0 surround (front left, front center, front right, rear left, rear right).\n* 6 channels: 5.1 surround (front left, front center, front right, rear left, rear right, LFE).\n* 7 channels: 6.1 surround (front left, front center, front right, side left, side right, rear center, LFE).\n* 8 channels: 7.1 surround (front left, front center, front right, side left, side right, rear left, rear right, LFE).\n\nSee: https://datatracker.ietf.org/doc/html/rfc7845.html#section-5.1.1.2\n\n## `OggVorbisDecoder`\n\nClass that decodes Ogg Vorbis data synchronously on the main thread.\n\n### Options\n```javascript\nconst decoder = new OggVorbisDecoder();\n```\n\n### Getters\n* `decoder.ready` *async*\n  * Returns a promise that is resolved when the WASM is compiled and ready to use.\n\n### Methods\n\n* `decoder.decode(vorbisData)` *async*\n  * `vorbisData` Uint8Array containing Ogg Vorbis data.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when streaming audio into the decoder.\n* `decoder.flush()` *async*\n  * Returns a promise that resolves with any remaining data in the buffer.\n  * Use this when you are finished piping audio in through the `decode` method to retrieve any remaining data in the buffer.\n* `decoder.decodeFile(vorbisData)` *async*\n  * `vorbisData` Uint8Array containing Ogg Vorbis data.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when decoding an entire file.\n* `decoder.decodeOggPages(oggPages: OggPage[])` *async*\n  * `oggPages` Array of Vorbis Ogg Pages.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when decoding with Ogg Pages that have already been parsed using [`codec-parser`](https://github.com/eshaz/codec-parser)\n* `decoder.reset()` *async*\n  * Resets the decoder so that a new stream of Ogg Vorbis data can be decoded.\n* `decoder.free()`\n  * De-allocates the memory used by the decoder.\n  * After calling `free()`, the current instance is made unusable, and a new instance will need to be created to decode additional Ogg Vorbis data.\n\n## `OggVorbisDecoderWebWorker`\n\nClass that decodes Ogg Vorbis data asynchronously within a web worker. Decoding is performed in a separate, non-blocking thread. Each new instance spawns a new worker allowing you to run multiple workers for concurrent decoding of multiple streams.\n\n### Options\n```javascript\nconst decoder = new OggVorbisDecoderWebWorker();\n```\n\n### Getters\n* `decoder.ready` *async*\n  * Returns a promise that is resolved when the WASM is compiled and ready to use.\n\n### Methods\n\n* `decoder.decode(vorbisData)` *async*\n  * `vorbisData` Uint8Array containing Ogg Vorbis data.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when streaming audio into the decoder.\n* `decoder.flush()` *async*\n  * Returns a promise that resolves with any remaining data in the buffer.\n  * Use this when you are finished piping audio in through the `decode` method to retrieve any remaining data in the buffer.\n* `decoder.decodeFile(vorbisData)` *async*\n  * `vorbisData` Uint8Array containing Ogg Vorbis data.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when decoding an entire file.\n* `decoder.decodeOggPages(oggPages: OggPage[])` *async*\n  * `oggPages` Array of Vorbis Ogg Pages.\n  * Returns a promise that resolves with the decoded audio.\n  * Use this when decoding with Ogg Pages that have already been parsed using [`codec-parser`](https://github.com/eshaz/codec-parser)\n* `decoder.reset()` *async*\n  * Resets the decoder so that a new stream of Ogg Vorbis data can be decoded.\n* `decoder.free()` *async\n  * De-allocates the memory used by the decoder.\n  * After calling `free()`, the current instance is made unusable, and a new instance will need to be created to decode additional Ogg Vorbis data.\n\n### Properly using the Web Worker interface\n\n`OggVorbisDecoderWebWorker` uses async functions to send operations to the web worker without blocking the main thread. To fully take advantage of the concurrency provided by web workers, your code should avoid using `await` on decode operations where it will block the main thread.\n\nEach method call on a `OggVorbisDecoderWebWorker` instance will queue up an operation to the web worker. Operations will complete within the web worker thread one at a time and in the same order in which the methods were called.\n\n  * **Good** Main thread is not blocked during each decode operation. The example `playAudio` function is called when each decode operation completes. Also, the next decode operation can begin while `playAudio` is doing work on the main thread.\n    ```javascript\n    const playAudio = ({ channelData, samplesDecoded, sampleRate }) => {\n      // does something to play the audio data.\n    }\n\n    decoder.decode(data1).then(playAudio);\n    decoder.decode(data2).then(playAudio);\n    decoder.decode(data3).then(playAudio);\n\n    // do some other operations while the audio is decoded\n    ```\n\n  * **Bad** Main thread is being blocked by `await` during each decode operation. Synchronous code is halted while decoding completes, negating the benefits of using a webworker.\n    ```javascript\n    const decoded1 = await decoder.decode(data1); // blocks the main thread\n    playAudio(decoded1);\n\n    const decoded2 = await decoder.decode(data2); // blocks the main thread\n    playAudio(decoded2);\n\n    const decoded3 = await decoder.decode(data3); // blocks the main thread\n    playAudio(decoded3);\n    ```\n## Examples\n\n### Decoding multiple files using a **single** instance of `OggVorbisDecoderWebWorker`\n\nThis example shows how to decode multiple files using a single `OggVorbisDecoderWebWorker` instance. This code iterates over an array of input files (Array of Uint8Arrays) and queues up each file to be decoded one at a time.\n\nFirst, wait for the decoder to become ready by calling `decoder.ready`.\n\nFor each iteration, `decode()` is called, it's result is pushed to the `decodedFiles` array, and `decoder.reset()` is called to prepare the decoder for a new file. These operations are queued up to the decoder instance and will complete one after another.\n\nFinally, a call to `decoder.free()` is queued to clean up the memory stored by the decoder. This resolves when it and all of the other operations before it complete.\n\nIt's important to note that there is only one `await` operations in this example. Decoding can happen asynchronously and you only need to `await` when you need to use the results of the decode operation.\n\n```javascript\n  const inputFiles = [file1, file2, file3] // Array of Uint8Array file data\n\n  const decoder = new OggVorbisDecoderWebWorker();\n\n  const decodedFiles = [];\n\n  const decodePromise = decoder.ready // wait for the decoder to be ready\n    .then(() => {\n      for (const file of inputFiles) {\n        decoder.decode(file) // queue the decode operation\n          .then((result) => decodedFiles.push(result)); // save the decode result after decode completes\n        decoder.reset(); // queue the reset operation\n      }\n    })\n    .then(() => decoder.free()); // queue the free operation that will execute after the above operations\n\n  // do sync operations here\n\n  // await when you need to have the all of the audio data decoded\n  await decodePromise;\n```\n### Decoding multiple files using **multiple** instances of `OggVorbisDecoderWebWorker`\n\nThis example shows how to decode multiple files using multiple instances of `OggVorbisDecoderWebWorker`. This code iterates over an array of input files (Array of Uint8Arrays) and spawns a new `OggVorbisDecoderWebWorker` instance for each file and decodes the file. If you want to take full advantage of multi-core devices, this is the approach you will want to take since it will parallelize the decoding\n\nFor each input file, a new decoder is created, and the file is decoded using the `decode()` after  `decoder.ready` is resolved. The result of the `decode()` operation is returned, and a `finally()` function on the promise calls `decoder.free()` to free up the instance after the decode operations are completed.\n\nFinally, `Promise.all()` wraps this array of promises and resolves when all decode operations are complete.\n\nIt's important to note that there is only one `await` operation in this example. Decoding can happen asynchronously and you only need to `await` when you need to use the results of the decode operation.\n\n```javascript\n  const inputFiles = [file1, file2, file3] // Array of Uint8Array file data\n\n  // loops through each Uint8Array in `inputFiles` and decodes the files in separate threads\n  const decodePromise = Promise.all(\n    inputFiles.map((file) => {\n      const decoder = new OggVorbisDecoderWebWorker();\n\n      return decoder.ready\n        .then(() => decoder.decode(file)) // decode the input file\n        .finally(() => decoder.free()); // free the decoder after resolving the decode result\n    })\n  );\n\n  // do sync operations here\n\n  // await when you need to have the all of the audio data decoded\n  const decodedFiles = await decodePromise;\n```"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@wasm-audio-decoders/ogg-vorbis/-/ogg-vorbis-0.1.16.tgz#56c17fb7366599cc81ab11639e5d39dd15b3a81d",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@wasm-audio-decoders/ogg-vorbis/-/ogg-vorbis-0.1.16.tgz",
    "hash": "56c17fb7366599cc81ab11639e5d39dd15b3a81d",
    "integrity": "sha512-HcEx4LPZbbzjhs9bTXgMaXLVCSMSo/egY9paJxAnE9tsYbvseAaGtVddLYktl3Qi/G+nW/ZzUXg4144izJjqCw==",
    "registry": "npm",
    "packageName": "@wasm-audio-decoders/ogg-vorbis",
    "cacheIntegrity": "sha512-HcEx4LPZbbzjhs9bTXgMaXLVCSMSo/egY9paJxAnE9tsYbvseAaGtVddLYktl3Qi/G+nW/ZzUXg4144izJjqCw== sha1-VsF/tzZlmcyBqxFjnl053RWzqB0="
  },
  "registry": "npm",
  "hash": "56c17fb7366599cc81ab11639e5d39dd15b3a81d"
}